name: Manzana Download (Apple TV+ Trailers)

# .github/workflows/manzana-download.yml @ v1.6.11
# Changes vs v1.6.10:
# - Runner: pin to ubuntu-22.04 for stability.
# - Phase 2: replace apt gpac install with MP4Box(gpac) bundle cache steps (START/END marked).
# - Fix: copy_lib() return code bug that could falsely mark missing deps.

on:
  workflow_dispatch:
    inputs:
      url:
        description: "ğŸ”— Apple TV é¡µé¢é“¾æ¥ï¼ˆmovie/show/clipï¼‰ã€‚å»ºè®®ç›´æ¥ç²˜è´´æµè§ˆå™¨åœ°å€æ å®Œæ•´ URLã€‚"
        required: true
        type: string

      trailer:
        description: "ğŸï¸ é€‰æ‹©è§†é¢‘ï¼št0/t1/t2... æˆ– allã€‚è‹¥è¯¥é¡µé¢ API åªæœ‰ t0ï¼Œä½†ç½‘é¡µæœ‰å¤šä¸ª clipï¼Œåˆ™ t1 ä¼šè‡ªåŠ¨æ˜ å°„ä¸ºç¬¬ 2 ä¸ª clipã€‚"
        required: false
        default: "t0"
        type: string

      default_only:
        description: "ğŸ¯ åªå–é»˜è®¤èƒŒæ™¯è§†é¢‘ï¼ˆ--defaultï¼‰ã€‚å¼€å¯åé€šå¸¸åªæœ‰ 1 ä¸ªè§†é¢‘ï¼›all ä¹Ÿç­‰ä»·äº t0ã€‚"
        required: false
        default: false
        type: boolean

      mode:
        description: "ğŸ›ï¸ é€‰æ‹©æ¨¡å¼ï¼špreset_* è‡ªåŠ¨é€‰è½¨ï¼›custom æ‰‹åŠ¨å¡«å†™ formatã€‚"
        required: true
        type: choice
        default: preset_av
        options:
          - preset_av
          - preset_video
          - custom

      preset_av_profile:
        description: "ğŸšï¸ é¢„è®¾ A/Vï¼ˆä»… mode=preset_av ç”Ÿæ•ˆï¼‰ï¼šè‡ªåŠ¨é€‰è§†é¢‘+æŒ‡å®šéŸ³é¢‘ç±»å‹ï¼ˆæ›´é€‚åˆä¸€é”®ï¼‰ã€‚"
        required: true
        type: choice
        default: 1080_SDR_AAC
        options:
          - 1080_SDR_AAC
          - 4K_DOVI_ATMOS
          - 4K_HDR_DD51

      preset_video_profile:
        description: "ğŸšï¸ é¢„è®¾è§†é¢‘ï¼ˆä»… mode=preset_video ç”Ÿæ•ˆï¼‰ï¼š1080/4K + SDR/HDR/DoViï¼ˆè‡ªåŠ¨æŒ‘åŒæ¡£æœ€é«˜ç ç‡ï¼‰ã€‚"
        required: true
        type: choice
        default: 1080_SDR
        options:
          - 1080_SDR
          - 4K_DOVI
          - 4K_HDR

      audio_quality:
        description: "ğŸ”Š éŸ³é¢‘è´¨é‡ï¼ˆä»… mode=preset_video ç”Ÿæ•ˆï¼‰ï¼šnone=çº¯è§†é¢‘ï¼›AAC/Atmos/DD5.1=è‡ªåŠ¨å›é€€åˆ°å¯ç”¨éŸ³è½¨ã€‚"
        required: true
        type: choice
        default: AAC
        options:
          - none
          - AAC
          - Atmos
          - DD5.1

      audio_lang:
        description: "ğŸ—£ï¸ éŸ³é¢‘è¯­è¨€ï¼ˆä»… preset_* ç”Ÿæ•ˆï¼‰ï¼šoriginal=ä¼˜å…ˆåŸå£°ï¼›è‹¥æŒ‡å®šè¯­è¨€ä¸å¯ç”¨ä¼šå›é€€ã€‚"
        required: true
        type: choice
        default: original
        options:
          - original
          - en
          - cmn-Hans
          - cmn-Hant
          - ja
          - ko
          - fr-FR
          - fr-CA
          - de
          - es-ES
          - es-419
          - it
          - pt-BR
          - ru

      sub_lang:
        description: "ğŸ’¬ å­—å¹•è¯­è¨€ï¼ˆä»… preset_* ç”Ÿæ•ˆï¼‰ï¼šnone=ä¸ä¸‹å­—å¹•ï¼›æŒ‡å®šè¯­è¨€ä¸å­˜åœ¨åˆ™è·³è¿‡å­—å¹•ï¼ˆä¸æŠ¥é”™ï¼‰ã€‚"
        required: true
        type: choice
        default: none
        options:
          - none
          - en
          - cmn-Hans
          - cmn-Hant
          - ja
          - ko
          - fr-FR
          - fr-CA
          - de
          - es-ES
          - es-419
          - it
          - pt-BR
          - ru

      format:
        description: "ğŸ§© ä»… mode=custom ç”Ÿæ•ˆï¼šç•™ç©º=åªåˆ—æ ¼å¼ä¸ä¸‹è½½ï¼›å¡«å†™å¦‚ v0+a2+s1ï¼ˆå¿…é¡»ä¸”åªèƒ½åŒ…å« 1 ä¸ª vNï¼‰ã€‚"
        required: false
        default: ""
        type: string

jobs:
  download:
    runs-on: ubuntu-22.04
    timeout-minutes: 60

    steps:
      - name: Validate inputs (fail fast + hints)
        run: |
          set -euo pipefail

          MODE="${{ inputs.mode }}"
          TRAILER="${{ inputs.trailer }}"
          FORMAT_IN="${{ inputs.format }}"
          DEFAULT_ONLY="${{ inputs.default_only }}"

          if [[ -z "$TRAILER" ]]; then
            echo "::error::Trailer ä¸ºç©ºã€‚è¯·ä½¿ç”¨ t0/t1/... æˆ– allã€‚"
            exit 1
          fi

          if [[ "$TRAILER" =~ ^(all|a|t[0-9]+)$ ]]; then
            echo "OK: trailer=$TRAILER"
          else
            echo "::error::Trailer æ— æ•ˆï¼š'$TRAILER'ï¼ˆæœŸæœ›ï¼št0/t1/... æˆ– allï¼‰"
            exit 1
          fi

          if [[ "$DEFAULT_ONLY" == "true" && "$TRAILER" =~ ^(all|a)$ ]]; then
            echo "::notice::default_only=true æ—¶ï¼Œall ç­‰ä»·äº t0ï¼ˆé¡µé¢é€šå¸¸åªæœ‰ 1 ä¸ªé»˜è®¤è§†é¢‘ï¼‰ã€‚"
          fi

          if [[ "$MODE" != "custom" && -n "$FORMAT_IN" ]]; then
            echo "::warning::å½“å‰ mode=$MODEï¼Œä¼šå¿½ç•¥ format è¾“å…¥ï¼ˆformat ä»… custom æ¨¡å¼ç”Ÿæ•ˆï¼‰ã€‚"
          fi

          if [[ "$MODE" == "custom" ]]; then
            if [[ -z "$FORMAT_IN" ]]; then
              echo "::notice::custom + format ä¸ºç©ºï¼šå°†åªåˆ—æ ¼å¼ï¼ˆ-Fï¼‰ï¼Œä¸ä¸‹è½½ã€‚"
            else
              F="$FORMAT_IN"
              if [[ ${#F} -ge 2 ]]; then
                if [[ ( "${F:0:1}" == "\"" && "${F: -1}" == "\"" ) || ( "${F:0:1}" == "'" && "${F: -1}" == "'" ) ]]; then
                  F="${F:1:-1}"
                fi
              fi

              if [[ "$F" =~ [[:space:]] ]]; then
                echo "::error::custom format å«ç©ºæ ¼ã€‚è¯·ç”¨ + è¿æ¥ï¼Œä¾‹å¦‚ v0+a0+s0"
                exit 1
              fi

              IFS='+' read -ra PARTS <<< "$F"
              vcount=0
              for p in "${PARTS[@]}"; do
                if [[ -z "$p" ]]; then
                  echo "::error::custom format å­˜åœ¨ç©º tokenï¼ˆå¯èƒ½æ˜¯ ++ï¼‰"
                  exit 1
                fi
                if [[ "$p" =~ ^[vV][0-9]+$ ]]; then
                  ((vcount+=1))
                elif [[ "$p" =~ ^[aA][0-9]+$ ]]; then
                  true
                elif [[ "$p" =~ ^[sS][0-9]+$ ]]; then
                  true
                else
                  echo "::error::custom format token æ— æ•ˆï¼š'$p'ï¼ˆåº”ä¸º vN/aN/sNï¼‰"
                  exit 1
                fi
              done

              if [[ "$vcount" -ne 1 ]]; then
                echo "::error::custom format å¿…é¡»ä¸”åªèƒ½åŒ…å« 1 ä¸ª vNï¼ˆè§†é¢‘è½¨ï¼‰ã€‚"
                exit 1
              fi

              if [[ "$TRAILER" =~ ^(all|a)$ ]]; then
                echo "::notice::custom + trailer=allï¼šä¼šå¯¹æ¯ä¸ªè§†é¢‘ä½¿ç”¨åŒä¸€ä¸ª formatã€‚è‹¥ä¸åŒè§†é¢‘çš„ v/a/s ç¼–å·ä¸ä¸€è‡´ï¼Œå¯èƒ½éƒ¨åˆ†å¤±è´¥ï¼ˆå±æ­£å¸¸ç°è±¡ï¼‰ã€‚"
              fi
            fi
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Phase 1 - List formats (-F) and save to formats.txt (dedup, grouped)
        run: |
          set -euo pipefail

          URL="${{ inputs.url }}"
          TRAILER="${{ inputs.trailer }}"
          DEFAULT_ONLY="${{ inputs.default_only }}"

          : > formats.txt

          DEFAULT_FLAG=""
          if [[ "$DEFAULT_ONLY" == "true" ]]; then
            DEFAULT_FLAG="--default-only"
          fi

          if [[ "$DEFAULT_ONLY" == "true" ]]; then
            echo "========== DEFAULT (single) ==========" | tee -a formats.txt
            echo "::group::Formats (default)"
            python manzana.py --default --no-prompt --trailer "$TRAILER" -F "$URL" | tee -a formats.txt
            echo "::endgroup::"
            exit 0
          fi

          # trailer=tN (single) with out-of-range fallback to clip N
          if ! [[ "$TRAILER" =~ ^(all|a)$ ]]; then
            idx="${TRAILER#t}"
            if ! [[ "$idx" =~ ^[0-9]+$ ]]; then
              echo "::error::Unexpected trailer format: $TRAILER"
              exit 1
            fi

            COUNT="$(python tools/list_trailers.py --url "$URL" $DEFAULT_FLAG | tail -n 1 | tr -d '\r\n')"
            if ! [[ "$COUNT" =~ ^[0-9]+$ ]]; then
              echo "::warning::Unable to parse trailer count; trying direct $TRAILER..."
              echo "========== TRAILER $TRAILER ==========" | tee -a formats.txt
              echo "::group::Formats ($TRAILER)"
              python manzana.py --no-prompt --trailer "$TRAILER" -F "$URL" | tee -a formats.txt
              echo "::endgroup::"
              exit 0
            fi

            if (( idx < COUNT )); then
              echo "========== TRAILER $TRAILER ==========" | tee -a formats.txt
              echo "::group::Formats ($TRAILER)"
              python manzana.py --no-prompt --trailer "$TRAILER" -F "$URL" | tee -a formats.txt
              echo "::endgroup::"
              exit 0
            fi

            echo "::notice::Phase 1: API provides only $COUNT trailer(s). Requested $TRAILER is out of range; falling back to clip index $idx." | tee -a formats.txt
            mapfile -t CLIPS_RAW < <(python tools/list_clip_urls.py --url "$URL" $DEFAULT_FLAG --resolve-titles)

            if [[ ${#CLIPS_RAW[@]} -le 0 ]]; then
              echo "::error::No clip URLs found for fallback. Cannot satisfy $TRAILER." | tee -a formats.txt
              exit 1
            fi

            if (( idx >= ${#CLIPS_RAW[@]} )); then
              echo "::error::Requested $TRAILER but clip list has only ${#CLIPS_RAW[@]} item(s)." | tee -a formats.txt
              exit 1
            fi

            clip_url="${CLIPS_RAW[$idx]}"
            clip_id="$(echo "$clip_url" | sed -n 's|.*/umc\.cmc\.\([^?&/]*\).*|\1|p')"
            [[ -z "$clip_id" ]] && clip_id="unknown"

            echo "========== CLIP (fallback for $TRAILER): $clip_url ==========" | tee -a formats.txt
            echo "::group::Formats (clip-$clip_id for $TRAILER)"
            python manzana.py --no-prompt --trailer t0 -F "$clip_url" | tee -a formats.txt
            echo "::endgroup::"
            exit 0
          fi

          # trailer=all path
          COUNT="$(python tools/list_trailers.py --url "$URL" $DEFAULT_FLAG | tail -n 1 | tr -d '\r\n')"
          if ! [[ "$COUNT" =~ ^[0-9]+$ ]]; then
            echo "::warning::Unable to parse trailer count for Phase 1; falling back to listing t0 only."
            echo "========== TRAILER t0 (fallback) ==========" | tee -a formats.txt
            echo "::group::Formats (t0 fallback)"
            python manzana.py --no-prompt --trailer t0 -F "$URL" | tee -a formats.txt
            echo "::endgroup::"
            exit 0
          fi

          if [[ "$COUNT" -gt 1 ]]; then
            echo "========== ALL TRAILERS (t0..t$((COUNT-1))) ==========" | tee -a formats.txt
            for ((i=0;i<COUNT;i++)); do
              echo "" | tee -a formats.txt
              echo "========== TRAILER t${i} ==========" | tee -a formats.txt
              echo "::group::Formats (t${i})"
              python manzana.py --no-prompt --trailer "t${i}" -F "$URL" | tee -a formats.txt
              echo "::endgroup::"
            done
            exit 0
          fi

          echo "========== ALL (clip fallback) ==========" | tee -a formats.txt
          mapfile -t CLIPS_RAW < <(python tools/list_clip_urls.py --url "$URL" $DEFAULT_FLAG --resolve-titles)

          if [[ ${#CLIPS_RAW[@]} -le 0 ]]; then
            echo "::warning::Clip fallback found 0 clip URLs. Listing trailer t0 as last resort." | tee -a formats.txt
            echo "========== TRAILER t0 (fallback) ==========" | tee -a formats.txt
            echo "::group::Formats (t0 fallback)"
            python manzana.py --no-prompt --trailer t0 -F "$URL" | tee -a formats.txt
            echo "::endgroup::"
            exit 0
          fi

          declare -A seen=()
          CLIPS=()
          for c in "${CLIPS_RAW[@]}"; do
            c="$(printf "%s" "$c" | tr -d '\r\n')"
            [[ -z "$c" ]] && continue
            if [[ -n "${seen[$c]+x}" ]]; then
              continue
            fi
            seen["$c"]=1
            CLIPS+=("$c")
          done

          echo "::notice::Phase 1 will list formats for ${#CLIPS[@]} clip(s) (no duplicates)." | tee -a formats.txt

          for clip_url in "${CLIPS[@]}"; do
            echo "" | tee -a formats.txt
            echo "========== CLIP: $clip_url ==========" | tee -a formats.txt

            clip_id="$(echo "$clip_url" | sed -n 's|.*/umc\.cmc\.\([^?&/]*\).*|\1|p')"
            [[ -z "$clip_id" ]] && clip_id="unknown"

            echo "::group::Formats (clip-$clip_id)"
            python manzana.py --no-prompt --trailer t0 -F "$clip_url" | tee -a formats.txt
            echo "::endgroup::"
          done

      - name: Upload formats as artifact (manzana-formats)
        uses: actions/upload-artifact@v4
        with:
          name: manzana-formats
          path: formats.txt
          if-no-files-found: error

      - name: Compute EFFECTIVE_FORMAT / PLAN (preset/custom)
        run: |
          set -euo pipefail

          MODE="${{ inputs.mode }}"
          URL="${{ inputs.url }}"
          TRAILER="${{ inputs.trailer }}"
          DEFAULT_ONLY="${{ inputs.default_only }}"

          DEFAULT_FLAG=""
          if [[ "$DEFAULT_ONLY" == "true" ]]; then
            DEFAULT_FLAG="--default-only"
          fi

          PLAN_FILE="$RUNNER_TEMP/manzana_plan.txt"
          : > "$PLAN_FILE"
          echo "FORMAT_PLAN_FILE=$PLAN_FILE" >> "$GITHUB_ENV"

          MAP_KIND=""
          MAP_TARGET=""

          map_trailer_single() {
            local url="$1"
            local trailer="$2"

            local idx="${trailer#t}"
            if ! [[ "$idx" =~ ^[0-9]+$ ]]; then
              echo "::error::Unexpected trailer format: $trailer"
              exit 1
            fi

            local count
            count="$(python tools/list_trailers.py --url "$url" $DEFAULT_FLAG | tail -n 1 | tr -d '\r\n')"
            if ! [[ "$count" =~ ^[0-9]+$ ]]; then
              MAP_KIND="trailers"
              MAP_TARGET="$trailer"
              return 0
            fi

            if (( idx < count )); then
              MAP_KIND="trailers"
              MAP_TARGET="$trailer"
              return 0
            fi

            echo "::notice::Requested $trailer but API count=$count. Falling back to clip index $idx."
            mapfile -t clips < <(python tools/list_clip_urls.py --url "$url" $DEFAULT_FLAG --resolve-titles)
            if [[ ${#clips[@]} -le 0 ]]; then
              echo "::error::Clip fallback found 0 clip URLs; cannot satisfy $trailer."
              exit 1
            fi
            if (( idx >= ${#clips[@]} )); then
              echo "::error::Requested $trailer but clip list has only ${#clips[@]} item(s)."
              exit 1
            fi

            MAP_KIND="clips"
            MAP_TARGET="${clips[$idx]}"
            return 0
          }

          if [[ "$MODE" == "custom" ]]; then
            F="${{ inputs.format }}"
            if [[ ${#F} -ge 2 ]]; then
              if [[ ( "${F:0:1}" == "\"" && "${F: -1}" == "\"" ) || ( "${F:0:1}" == "'" && "${F: -1}" == "'" ) ]]; then
                F="${F:1:-1}"
              fi
            fi
            F="$(printf "%s" "$F" | tr -d '\r\n')"

            if [[ -z "$F" ]]; then
              echo "EFFECTIVE_FORMAT=" >> "$GITHUB_ENV"
              echo "DO_DOWNLOAD=false" >> "$GITHUB_ENV"
              echo "DOWNLOAD_ALL=false" >> "$GITHUB_ENV"
              echo "PLAN_KIND=single" >> "$GITHUB_ENV"
              echo "mode=custom: format empty -> list only, no download."
              exit 0
            fi

            echo "DO_DOWNLOAD=true" >> "$GITHUB_ENV"

            if [[ "$TRAILER" =~ ^(all|a)$ ]]; then
              COUNT="$(python tools/list_trailers.py --url "$URL" $DEFAULT_FLAG | tail -n 1 | tr -d '\r\n')"
              if ! [[ "$COUNT" =~ ^[0-9]+$ ]]; then
                echo "::error::Unable to parse trailer count: '$COUNT'"
                exit 1
              fi

              if [[ "$COUNT" -gt 1 ]]; then
                echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
                echo "PLAN_KIND=trailers" >> "$GITHUB_ENV"
                echo "::notice::custom mode + trailer=all -> API trailers count=$COUNT (t0..t$((COUNT-1))). Using the SAME format for each."
                for ((i=0;i<COUNT;i++)); do
                  echo "t${i} $F" >> "$PLAN_FILE"
                done
                echo "::notice::Computed plan (trailer -> format):"
                cat "$PLAN_FILE"
                exit 0
              fi

              echo "::notice::custom mode + trailer=all -> API count=$COUNT (<=1). Falling back to clip URLs from HTML..."
              echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
              echo "PLAN_KIND=clips" >> "$GITHUB_ENV"

              mapfile -t CLIPS < <(python tools/list_clip_urls.py --url "$URL" $DEFAULT_FLAG --resolve-titles)
              if [[ ${#CLIPS[@]} -le 0 ]]; then
                echo "::error::Clip fallback found 0 clip URLs. Unable to continue."
                exit 1
              fi

              for clip_url in "${CLIPS[@]}"; do
                clip_url="$(printf "%s" "$clip_url" | tr -d '\r\n')"
                [[ -z "$clip_url" ]] && continue
                echo "$clip_url $F" >> "$PLAN_FILE"
              done

              echo "::notice::Computed plan (clip_url -> format):"
              cat "$PLAN_FILE"
              exit 0
            fi

            map_trailer_single "$URL" "$TRAILER"
            if [[ "$MAP_KIND" == "clips" ]]; then
              echo "DO_DOWNLOAD=true" >> "$GITHUB_ENV"
              echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
              echo "PLAN_KIND=clips" >> "$GITHUB_ENV"
              echo "$MAP_TARGET $F" >> "$PLAN_FILE"
              echo "::notice::Computed plan (single clip via $TRAILER -> format):"
              cat "$PLAN_FILE"
              exit 0
            fi

            echo "EFFECTIVE_FORMAT=$F" >> "$GITHUB_ENV"
            echo "DOWNLOAD_ALL=false" >> "$GITHUB_ENV"
            echo "PLAN_KIND=single" >> "$GITHUB_ENV"
            echo "mode=custom: will download with format: $F"
            exit 0
          fi

          if [[ "$MODE" == "preset_av" || "$MODE" == "preset_video" ]]; then
            echo "DO_DOWNLOAD=true" >> "$GITHUB_ENV"

            if [[ "$TRAILER" =~ ^(all|a)$ ]]; then
              COUNT="$(python tools/list_trailers.py --url "$URL" $DEFAULT_FLAG | tail -n 1 | tr -d '\r\n')"
              if ! [[ "$COUNT" =~ ^[0-9]+$ ]]; then
                echo "::error::Unable to parse trailer count: '$COUNT'"
                exit 1
              fi

              if [[ "$COUNT" -gt 1 ]]; then
                echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
                echo "PLAN_KIND=trailers" >> "$GITHUB_ENV"
                echo "::notice::preset mode + trailer=all -> API trailers count=$COUNT (t0..t$((COUNT-1)))."

                sel_failed=()
                for ((i=0;i<COUNT;i++)); do
                  TID="t${i}"
                  set +e
                  if [[ "$MODE" == "preset_av" ]]; then
                    EFF="$(python tools/select_format.py --url "$URL" --trailer "$TID" $DEFAULT_FLAG --mode preset_av \
                      --preset-av-profile "${{ inputs.preset_av_profile }}" --audio-lang "${{ inputs.audio_lang }}" --sub-lang "${{ inputs.sub_lang }}" \
                      | tail -n 1 | tr -d '\r\n')"
                  else
                    EFF="$(python tools/select_format.py --url "$URL" --trailer "$TID" $DEFAULT_FLAG --mode preset_video \
                      --preset-video-profile "${{ inputs.preset_video_profile }}" --audio-quality "${{ inputs.audio_quality }}" \
                      --audio-lang "${{ inputs.audio_lang }}" --sub-lang "${{ inputs.sub_lang }}" \
                      | tail -n 1 | tr -d '\r\n')"
                  fi
                  RC=$?
                  set -e
                  if [[ $RC -ne 0 || -z "$EFF" ]]; then
                    sel_failed+=("$TID")
                    echo "::warning::Selector failed for $TID (skipping)."
                    continue
                  fi
                  echo "$TID $EFF" >> "$PLAN_FILE"
                done

                if [[ ! -s "$PLAN_FILE" ]]; then
                  echo "::error::All trailers failed during selection (no plan entries)."
                  exit 1
                fi

                echo "::notice::Computed plan (trailer -> format):"
                cat "$PLAN_FILE"
                if [[ ${#sel_failed[@]} -gt 0 ]]; then
                  echo "::warning::Selector failed for trailers: ${sel_failed[*]}"
                fi
                exit 0
              fi

              echo "::notice::API trailer count=$COUNT (<=1). Falling back to clip URLs from HTML..."
              echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
              echo "PLAN_KIND=clips" >> "$GITHUB_ENV"

              mapfile -t CLIPS < <(python tools/list_clip_urls.py --url "$URL" $DEFAULT_FLAG --resolve-titles)
              if [[ ${#CLIPS[@]} -le 0 ]]; then
                echo "::error::Clip fallback found 0 clip URLs. Unable to continue."
                exit 1
              fi

              echo "::notice::Clip fallback: found ${#CLIPS[@]} clip URLs."
              for clip_url in "${CLIPS[@]}"; do
                clip_url="$(printf "%s" "$clip_url" | tr -d '\r\n')"
                [[ -z "$clip_url" ]] && continue

                set +e
                if [[ "$MODE" == "preset_av" ]]; then
                  EFF="$(python tools/select_format.py --url "$clip_url" --trailer t0 $DEFAULT_FLAG --mode preset_av \
                    --preset-av-profile "${{ inputs.preset_av_profile }}" --audio-lang "${{ inputs.audio_lang }}" --sub-lang "${{ inputs.sub_lang }}" \
                    | tail -n 1 | tr -d '\r\n')"
                else
                  EFF="$(python tools/select_format.py --url "$clip_url" --trailer t0 $DEFAULT_FLAG --mode preset_video \
                    --preset-video-profile "${{ inputs.preset_video_profile }}" --audio-quality "${{ inputs.audio_quality }}" \
                    --audio-lang "${{ inputs.audio_lang }}" --sub-lang "${{ inputs.sub_lang }}" \
                    | tail -n 1 | tr -d '\r\n')"
                fi
                RC=$?
                set -e
                if [[ $RC -ne 0 || -z "$EFF" ]]; then
                  echo "::warning::Selector failed for clip URL (skipping): $clip_url"
                  continue
                fi
                echo "$clip_url $EFF" >> "$PLAN_FILE"
              done

              if [[ ! -s "$PLAN_FILE" ]]; then
                echo "::error::All clip URLs failed during selection (no plan entries)."
                exit 1
              fi

              echo "::notice::Computed plan (clip_url -> format):"
              cat "$PLAN_FILE"
              exit 0
            fi

            map_trailer_single "$URL" "$TRAILER"
            if [[ "$MAP_KIND" == "clips" ]]; then
              echo "DO_DOWNLOAD=true" >> "$GITHUB_ENV"
              echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
              echo "PLAN_KIND=clips" >> "$GITHUB_ENV"

              if [[ "$MODE" == "preset_av" ]]; then
                EFF="$(python tools/select_format.py --url "$MAP_TARGET" --trailer t0 $DEFAULT_FLAG --mode preset_av \
                  --preset-av-profile "${{ inputs.preset_av_profile }}" --audio-lang "${{ inputs.audio_lang }}" --sub-lang "${{ inputs.sub_lang }}" \
                  | tail -n 1 | tr -d '\r\n')"
              else
                EFF="$(python tools/select_format.py --url "$MAP_TARGET" --trailer t0 $DEFAULT_FLAG --mode preset_video \
                  --preset-video-profile "${{ inputs.preset_video_profile }}" --audio-quality "${{ inputs.audio_quality }}" \
                  --audio-lang "${{ inputs.audio_lang }}" --sub-lang "${{ inputs.sub_lang }}" \
                  | tail -n 1 | tr -d '\r\n')"
              fi

              if [[ -z "$EFF" ]]; then
                echo "::error::Selector failed for fallback clip ($TRAILER -> $MAP_TARGET)"
                exit 1
              fi

              echo "$MAP_TARGET $EFF" >> "$PLAN_FILE"
              echo "::notice::Computed plan (single clip via $TRAILER -> format):"
              cat "$PLAN_FILE"
              exit 0
            fi

            echo "DOWNLOAD_ALL=false" >> "$GITHUB_ENV"
            echo "PLAN_KIND=single" >> "$GITHUB_ENV"

            if [[ "$MODE" == "preset_av" ]]; then
              EFF="$(python tools/select_format.py --url "$URL" --trailer "$TRAILER" $DEFAULT_FLAG --mode preset_av \
                --preset-av-profile "${{ inputs.preset_av_profile }}" --audio-lang "${{ inputs.audio_lang }}" --sub-lang "${{ inputs.sub_lang }}" \
                | tail -n 1 | tr -d '\r\n')"
            else
              EFF="$(python tools/select_format.py --url "$URL" --trailer "$TRAILER" $DEFAULT_FLAG --mode preset_video \
                --preset-video-profile "${{ inputs.preset_video_profile }}" --audio-quality "${{ inputs.audio_quality }}" \
                --audio-lang "${{ inputs.audio_lang }}" --sub-lang "${{ inputs.sub_lang }}" \
                | tail -n 1 | tr -d '\r\n')"
            fi

            if [[ -z "$EFF" ]]; then
              echo "::error::Selector returned empty effective format."
              exit 1
            fi

            echo "EFFECTIVE_FORMAT=$EFF" >> "$GITHUB_ENV"
            echo "::notice::preset mode -> computed format: $EFF"
            exit 0
          fi

          echo "::error::Unknown mode '$MODE'"
          exit 1

      - name: Cache FFmpeg (BtbN)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: ~/.local/ffmpeg-btbn
          key: ffmpeg-btbn-master-latest-linux64-gpl-v1

      - name: Install FFmpeg (BtbN Daily Build)
        if: ${{ env.DO_DOWNLOAD == 'true' && steps.cache-ffmpeg.outputs.cache-hit != 'true' }}
        run: |
          mkdir -p ~/.local/ffmpeg-btbn
          wget -O /tmp/ffmpeg.tar.xz https://github.com/BtbN/FFmpeg-Builds/releases/latest/download/ffmpeg-master-latest-linux64-gpl.tar.xz
          tar -xf /tmp/ffmpeg.tar.xz -C ~/.local/ffmpeg-btbn --strip-components=1
          ls -la ~/.local/ffmpeg-btbn/bin || true

      - name: Add FFmpeg to PATH
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          echo "$HOME/.local/ffmpeg-btbn/bin" >> $GITHUB_PATH

      - name: Verify FFmpeg in PATH
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          command -v ffmpeg
          ffmpeg -version | head -n 3
          command -v ffprobe
          ffprobe -version | head -n 3

      # ===== MP4Box (gpac) bundle steps START (MP4Box ä¸“ç”¨æ­¥éª¤å¼€å§‹ï¼›ä¸å…¶å®ƒæ­¥éª¤é€»è¾‘æ— å…³) =====

      - name: Detect Ubuntu VERSION_ID (for stable gpac cache key) [Phase 2 only]
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          set -euo pipefail
          . /etc/os-release
          echo "UBUNTU_VERSION_ID=$VERSION_ID" >> "$GITHUB_ENV"
          echo "Detected UBUNTU_VERSION_ID=$VERSION_ID"

      - name: Cache MP4Box bundle (gpac) [Phase 2 only]
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        id: cache-gpac
        uses: actions/cache@v4
        with:
          path: ~/.local/gpac-bundle
          key: gpac-bundle-${{ runner.os }}-ubuntu${{ env.UBUNTU_VERSION_ID }}-${{ runner.arch }}-rev2

      - name: Verify cached MP4Box bundle (self-heal marker) [Phase 2 only]
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        id: verify-gpac
        run: |
          set -euo pipefail
          BUNDLE="$HOME/.local/gpac-bundle"
          if [[ -x "$BUNDLE/bin/MP4Box" && -x "$BUNDLE/bin/MP4Box.bin" ]]; then
            export PATH="$BUNDLE/bin:$PATH"
            if MP4Box -version >/dev/null 2>&1; then
              echo "ok=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi
          echo "ok=false" >> "$GITHUB_OUTPUT"

      - name: Build gpac bundle on miss or broken cache (apt + ldd + gpac modules) [Phase 2 only]
        if: ${{ env.DO_DOWNLOAD == 'true' && (steps.cache-gpac.outputs.cache-hit != 'true' || steps.verify-gpac.outputs.ok != 'true') }}
        run: |
          set -euo pipefail

          # If cache-hit but bundle is broken, rebuild cleanly to avoid mixed files.
          rm -rf "$HOME/.local/gpac-bundle"

          sudo apt-get update
          sudo apt-get install -y gpac

          MP4BOX_PATH="$(command -v MP4Box)"
          echo "MP4Box path: $MP4BOX_PATH"

          BUNDLE="$HOME/.local/gpac-bundle"
          BIN="$BUNDLE/bin"
          LIB="$BUNDLE/lib"
          mkdir -p "$BIN" "$LIB"

          cp -av "$MP4BOX_PATH" "$BIN/MP4Box.bin"

          copy_lib() {
            local p="$1"
            [[ -z "$p" ]] && return 0
            if [[ ! -e "$p" ]]; then
              echo "::warning::lib not found on disk: $p"
              return 1
            fi

            local base real real_base
            base="$(basename "$p")"
            real="$(readlink -f "$p" || true)"
            [[ -z "$real" || ! -e "$real" ]] && real="$p"
            real_base="$(basename "$real")"

            if [[ ! -e "$LIB/$real_base" ]]; then
              cp -av "$real" "$LIB/"
            fi

            if [[ "$base" != "$real_base" ]]; then
              ln -sf "$real_base" "$LIB/$base"
            fi

            return 0
          }

          missing=0
          while IFS= read -r line; do
            if echo "$line" | grep -q "not found"; then
              echo "::error::Missing dependency: $line"
              missing=1
              continue
            fi

            p="$(echo "$line" | awk '{for(i=1;i<=NF;i++) if($i ~ /^\//) {print $i; exit}}')"
            [[ -z "$p" ]] && continue
            echo "$p" | grep -q "linux-vdso" && continue

            if ! copy_lib "$p"; then
              missing=1
            fi
          done < <(ldd "$BIN/MP4Box.bin" || true)

          if [[ "$missing" -ne 0 ]]; then
            echo "::error::Some dependencies were missing/unpackable."
            exit 1
          fi

          # Bundle GPAC modules directory into $LIB/gpac
          MOD_SRC=""
          for d in /usr/lib/*/gpac /usr/lib/*/gpac/modules; do
            [[ -d "$d" ]] && { MOD_SRC="$d"; break; }
          done
          if [[ -z "$MOD_SRC" ]]; then
            MOD_SRC="$(dpkg -L gpac 2>/dev/null | grep -E '/gpac(/modules)?$' | head -n 1 || true)"
          fi
          if [[ -n "$MOD_SRC" && -d "$MOD_SRC" ]]; then
            mkdir -p "$LIB/gpac"
            cp -a "$MOD_SRC"/. "$LIB/gpac/" || true
          else
            echo "::warning::Could not locate GPAC modules directory to bundle (may affect plugin-based features)."
          fi

          # Wrapper to set LD_LIBRARY_PATH for bundled libs
          cat > "$BIN/MP4Box" <<'SH'
          #!/usr/bin/env bash
          set -euo pipefail
          DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          export LD_LIBRARY_PATH="$DIR/../lib:${LD_LIBRARY_PATH:-}"
          exec "$DIR/MP4Box.bin" "$@"
          SH
          chmod +x "$BIN/MP4Box"

      - name: Use MP4Box bundle (cache hit => no apt install) [Phase 2 only]
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          set -euo pipefail
          BUNDLE_BIN="$HOME/.local/gpac-bundle/bin"
          export PATH="$BUNDLE_BIN:$PATH"
          echo "$BUNDLE_BIN" >> "$GITHUB_PATH"
          command -v MP4Box
          MP4Box -version || true

      - name: Quick runtime check (ldd + run) - realistic env [Phase 2 only]
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          set -euo pipefail

          BUNDLE="$HOME/.local/gpac-bundle"
          export LD_LIBRARY_PATH="$BUNDLE/lib:${LD_LIBRARY_PATH:-}"

          ldd "$BUNDLE/bin/MP4Box.bin" | tee /tmp/ldd-mp4box.txt
          ! grep -q "not found" /tmp/ldd-mp4box.txt

      # ===== MP4Box (gpac) bundle steps END (MP4Box ä¸“ç”¨æ­¥éª¤ç»“æŸï¼›ä¸å…¶å®ƒæ­¥éª¤é€»è¾‘æ— å…³) =====

      - name: Phase 2 - Download (custom single / custom all / preset single / preset all + clip fallback) [grouped]
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        env:
          PYTHONUNBUFFERED: "1"
        run: |
          set -euo pipefail

          URL="${{ inputs.url }}"
          DEFAULT_ONLY="${{ inputs.default_only }}"
          MODE="${{ inputs.mode }}"
          DOWNLOAD_ALL="${{ env.DOWNLOAD_ALL }}"
          PLAN_KIND="${{ env.PLAN_KIND }}"
          PLAN_FILE="${{ env.FORMAT_PLAN_FILE }}"
          EFF="${{ env.EFFECTIVE_FORMAT }}"
          TRAILER="${{ inputs.trailer }}"

          default_args=()
          if [[ "$DEFAULT_ONLY" == "true" ]]; then
            default_args+=(--default)
          fi

          failures=()
          success_count=0

          if [[ "$DOWNLOAD_ALL" == "true" ]]; then
            if [[ ! -s "$PLAN_FILE" ]]; then
              echo "::error::Plan file missing or empty: $PLAN_FILE"
              exit 1
            fi

            echo "::notice::Downloading multiple items (continue on failures). PLAN_KIND=$PLAN_KIND MODE=$MODE"

            while read -r target fmt; do
              [[ -z "$target" || -z "$fmt" ]] && continue

              if [[ "$PLAN_KIND" == "clips" ]]; then
                clip_url="$target"
                clip_id="$(echo "$clip_url" | sed -n 's|.*/umc\.cmc\.\([^?&/]*\).*|\1|p')"
                [[ -z "$clip_id" ]] && clip_id="unknown"

                echo "::group::Download (clip-$clip_id) fmt=$fmt"
                echo "::notice::Downloading clip URL with format=$fmt"
                set +e
                python manzana.py "${default_args[@]}" --no-prompt --trailer t0 -f "$fmt" "$clip_url"
                rc=$?
                set -e
                echo "::endgroup::"

                if [[ $rc -ne 0 ]]; then
                  failures+=("$clip_url")
                  echo "::warning::Download failed for clip (rc=$rc). Continuing..."
                else
                  ((success_count+=1))
                fi
              else
                tid="$target"
                echo "::group::Download ($tid) fmt=$fmt"
                echo "::notice::Downloading $tid with format=$fmt"
                set +e
                python manzana.py "${default_args[@]}" --no-prompt --trailer "$tid" -f "$fmt" "$URL"
                rc=$?
                set -e
                echo "::endgroup::"

                if [[ $rc -ne 0 ]]; then
                  failures+=("$tid")
                  echo "::warning::Download failed for $tid (rc=$rc). Continuing..."
                else
                  ((success_count+=1))
                fi
              fi
            done < "$PLAN_FILE"
          else
            echo "::group::Download (single) trailer=$TRAILER fmt=$EFF"
            echo "::notice::Downloading single trailer $TRAILER with format=$EFF"
            python manzana.py "${default_args[@]}" --no-prompt --trailer "$TRAILER" -f "$EFF" "$URL"
            echo "::endgroup::"
            success_count=1
          fi

          if [[ $success_count -le 0 ]]; then
            echo "::error::All downloads failed (no successful outputs)."
            exit 1
          fi

          if [[ ${#failures[@]} -gt 0 ]]; then
            echo "::warning::Some items failed to download:"
            for f in "${failures[@]}"; do
              echo "::warning:: - $f"
            done
          fi

      - name: Inspect output media info (ffprobe summary + JSON) [safe report names]
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          set -euo pipefail

          mkdir -p report
          : > report/manifest.tsv

          shopt -s nullglob
          files=(output/*.mp4)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No mp4 found in output/"
            exit 1
          fi

          for f in "${files[@]}"; do
            base="$(basename "$f")"
            echo "=== Inspecting: $base ==="

            sid="$(printf '%s' "$base" | sha1sum | awk '{print substr($1,1,12)}')"
            printf '%s\t%s\n' "$sid" "$base" >> report/manifest.tsv

            echo "--- FORMAT (container) ---"
            ffprobe -hide_banner -v error \
              -show_entries format=filename,format_name,duration,size,bit_rate \
              -of default=nw=1 "$f"

            echo "--- STREAMS (tracks, includes bit_rate when available) ---"
            ffprobe -hide_banner -v error \
              -show_entries stream=index,codec_type,codec_name,profile,bit_rate,width,height,avg_frame_rate,channels,channel_layout,sample_rate:stream_tags=language,title \
              -of default=nw=1 "$f"

            echo "--- JSON (artifact) ---"
            ffprobe -hide_banner -v error \
              -show_format -show_streams \
              -print_format json "$f" > "report/${sid}.ffprobe.json"
          done

          echo "=== Report manifest ==="
          cat report/manifest.tsv

      - name: Upload inspection report as artifact (manzana-report)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: manzana-report
          path: report/
          if-no-files-found: error

      - name: Upload output as artifact (manzana-output)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: manzana-output
          path: output/
          if-no-files-found: error
