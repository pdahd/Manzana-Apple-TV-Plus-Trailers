name: Manzana Download (Apple TV+ Trailers)

# .github/workflows/manzana-download.yml @ v1.6.0
# Enhancements:
# - Preset modes now support trailer=all (fail_fast=false):
#   - Compute formats per-trailer (t0..tN-1) using tools/select_format.py
#   - Download each trailer, continue on failures
#   - Summarize failures as ::warning::
#   - If ALL downloads fail -> exit 1
# - Uses tools/list_trailers.py to get trailer count (stdout clean)
# - Keeps: Phase-1 list formats, default_only applied to -F, ffmpeg cache, ffprobe inspect, artifacts

on:
  workflow_dispatch:
    inputs:
      url:
        description: "Apple TV URL (movie/show page)"
        required: true
        type: string

      trailer:
        description: 'Trailer selector: use t0, t1, t2... (e.g. "t0") or "all". In preset modes, "all" will apply presets to each trailer (t0..tN-1).'
        required: false
        default: "t0"
        type: string

      default_only:
        description: "Use --default (only default trailer metadata). If enabled, the page usually has a single default video (trailer=all behaves like t0)."
        required: false
        default: false
        type: boolean

      # --- Mode switch ---
      mode:
        description: "Selection mode: preset menus (recommended) OR custom format string."
        required: true
        type: choice
        default: preset_av
        options:
          - preset_av
          - preset_video
          - custom

      # --- Preset AV (fixed combos) ---
      preset_av_profile:
        description: "Preset A/V profile (ONLY used when mode=preset_av)."
        required: true
        type: choice
        default: 1080_SDR_AAC
        options:
          - 1080_SDR_AAC
          - 4K_DOVI_ATMOS
          - 4K_HDR_DD51

      # --- Preset Video (video-first; audio optional) ---
      preset_video_profile:
        description: "Preset video profile (ONLY used when mode=preset_video). Fallback chain: 4K DoVi/HDR -> 1080 SDR -> 720 SDR -> error."
        required: true
        type: choice
        default: 1080_SDR
        options:
          - 1080_SDR
          - 4K_DOVI
          - 4K_HDR

      audio_quality:
        description: "Audio quality (ONLY used when mode=preset_video). Fallback: if Atmos/DD5.1 not available -> AAC. Use 'none' for a true video-only output."
        required: true
        type: choice
        default: AAC
        options:
          - none
          - AAC
          - Atmos
          - DD5.1

      audio_lang:
        description: 'Audio language (preset modes only). "original" = original-content track. If selected language not available -> fallback to best original AAC (compatibility).'
        required: true
        type: choice
        default: original
        options:
          - original
          - en
          - cmn-Hans
          - cmn-Hant
          - ja
          - ko
          - fr-FR
          - fr-CA
          - de
          - es-ES
          - es-419
          - it
          - pt-BR
          - ru

      sub_lang:
        description: 'Subtitle language (preset modes only). Default "none". If subtitles missing or language not found -> no subtitles (no error).'
        required: true
        type: choice
        default: none
        options:
          - none
          - en
          - cmn-Hans
          - cmn-Hant
          - ja
          - ko
          - fr-FR
          - fr-CA
          - de
          - es-ES
          - es-419
          - it
          - pt-BR
          - ru

      # --- Custom format string (yt-dlp style) ---
      format:
        description: 'CUSTOM mode only. Recommended workflow: (1) leave EMPTY on first run to ONLY LIST formats (Phase 1) and upload formats.txt (NO DOWNLOAD). (2) rerun and set format. Must include EXACTLY ONE vN. Examples: v6 | v6+a0 | v6+a0+s4 | v6+a0+a4+s4+s5. Audio-only/sub-only not supported.'
        required: false
        default: ""
        type: string

jobs:
  download:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Validate inputs (fail fast)
        run: |
          set -euo pipefail

          MODE="${{ inputs.mode }}"
          TRAILER="${{ inputs.trailer }}"
          FORMAT_IN="${{ inputs.format }}"

          # ---- trailer validation ----
          if [[ -z "$TRAILER" ]]; then
            echo "::error::Input 'trailer' is empty. Use t0, t1, t2... or all."
            exit 1
          fi

          # allow: all / a / t<number>
          if [[ "$TRAILER" =~ ^(all|a|t[0-9]+)$ ]]; then
            echo "OK: trailer=$TRAILER"
          else
            echo "::error::Invalid trailer input: '$TRAILER'"
            echo "Expected: t0, t1, t2... (t + digits) OR 'all' (or 'a')."
            echo "Do NOT input spaces/slashes, e.g. 't0 / t1 / all'."
            exit 1
          fi

          # ---- custom format validation (only when mode=custom and format provided) ----
          if [[ "$MODE" == "custom" ]]; then
            if [[ -z "$FORMAT_IN" ]]; then
              echo "OK: mode=custom and format is EMPTY -> this run will ONLY LIST formats (Phase 1). No download will happen."
              echo "Tip: After you pick IDs, rerun with format like: v6+a0+s4"
            else
              # Strip wrapping quotes if pasted
              F="$FORMAT_IN"
              if [[ ${#F} -ge 2 ]]; then
                if [[ ( "${F:0:1}" == "\"" && "${F: -1}" == "\"" ) || ( "${F:0:1}" == "'" && "${F: -1}" == "'" ) ]]; then
                  F="${F:1:-1}"
                fi
              fi

              if [[ "$F" =~ [[:space:]] ]]; then
                echo "::error::Invalid custom format: contains whitespace. Use '+' between ids, e.g. v6+a0+s4"
                exit 1
              fi

              IFS='+' read -ra PARTS <<< "$F"
              vcount=0
              for p in "${PARTS[@]}"; do
                if [[ -z "$p" ]]; then
                  echo "::error::Invalid custom format: empty token (check for '++')."
                  exit 1
                fi
                if [[ "$p" =~ ^[vV][0-9]+$ ]]; then
                  ((vcount+=1))
                elif [[ "$p" =~ ^[aA][0-9]+$ ]]; then
                  true
                elif [[ "$p" =~ ^[sS][0-9]+$ ]]; then
                  true
                else
                  echo "::error::Invalid token '$p' in custom format."
                  echo "Allowed tokens: vN (video), aN (audio), sN (subtitle)."
                  exit 1
                fi
              done

              if [[ "$vcount" -ne 1 ]]; then
                echo "::error::Invalid custom format: must include EXACTLY ONE video id (vN)."
                echo "Valid examples: v6 | v6+a0 | v6+a0+s4"
                exit 1
              fi

              echo "OK: custom format looks valid."
            fi
          else
            # preset modes: ignore 'format' field, but warn if user filled it
            if [[ -n "$FORMAT_IN" ]]; then
              echo "::warning::mode=$MODE: input 'format' will be ignored (preset mode uses selector)."
            fi
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Phase 1 - List formats (-F) and save to formats.txt
        run: |
          if [ "${{ inputs.default_only }}" = "true" ]; then
            python manzana.py --default --no-prompt --trailer "${{ inputs.trailer }}" -F "${{ inputs.url }}" | tee formats.txt
          else
            python manzana.py --no-prompt --trailer "${{ inputs.trailer }}" -F "${{ inputs.url }}" | tee formats.txt
          fi

      - name: Upload formats as artifact (manzana-formats)
        uses: actions/upload-artifact@v4
        with:
          name: manzana-formats
          path: formats.txt
          if-no-files-found: error

      - name: Compute EFFECTIVE_FORMAT / PLAN (preset/custom)
        run: |
          set -euo pipefail

          MODE="${{ inputs.mode }}"
          URL="${{ inputs.url }}"
          TRAILER="${{ inputs.trailer }}"
          DEFAULT_ONLY="${{ inputs.default_only }}"

          DEFAULT_FLAG=""
          if [[ "$DEFAULT_ONLY" == "true" ]]; then
            DEFAULT_FLAG="--default-only"
          fi

          PLAN_FILE="$RUNNER_TEMP/manzana_plan.txt"
          : > "$PLAN_FILE"

          echo "FORMAT_PLAN_FILE=$PLAN_FILE" >> "$GITHUB_ENV"

          if [[ "$MODE" == "custom" ]]; then
            F="${{ inputs.format }}"
            if [[ ${#F} -ge 2 ]]; then
              if [[ ( "${F:0:1}" == "\"" && "${F: -1}" == "\"" ) || ( "${F:0:1}" == "'" && "${F: -1}" == "'" ) ]]; then
                F="${F:1:-1}"
              fi
            fi
            F="$(printf "%s" "$F" | tr -d '\r\n')"

            echo "EFFECTIVE_FORMAT=$F" >> "$GITHUB_ENV"
            echo "DOWNLOAD_ALL=false" >> "$GITHUB_ENV"

            if [[ -z "$F" ]]; then
              echo "DO_DOWNLOAD=false" >> "$GITHUB_ENV"
              echo "mode=custom: format empty -> list only, no download."
            else
              echo "DO_DOWNLOAD=true" >> "$GITHUB_ENV"
              echo "mode=custom: will download with format: $F"
            fi

          elif [[ "$MODE" == "preset_av" || "$MODE" == "preset_video" ]]; then
            # preset modes always download (unless all trailers fail in plan or selection step)
            echo "DO_DOWNLOAD=true" >> "$GITHUB_ENV"

            # Expand trailer=all/a into t0..tN-1 plan
            if [[ "$TRAILER" =~ ^(all|a)$ ]]; then
              COUNT="$(python tools/list_trailers.py --url "$URL" $DEFAULT_FLAG | tail -n 1 | tr -d '\r\n')"
              if ! [[ "$COUNT" =~ ^[0-9]+$ ]]; then
                echo "::error::Unable to parse trailer count: '$COUNT'"
                exit 1
              fi

              if [[ "$COUNT" -le 0 ]]; then
                echo "::error::No trailers found."
                exit 1
              fi

              echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
              echo "::notice::preset mode + trailer=all -> computing plan for $COUNT trailers (t0..t$((COUNT-1)))."

              sel_failed=()

              for ((i=0;i<COUNT;i++)); do
                TID="t${i}"

                set +e
                if [[ "$MODE" == "preset_av" ]]; then
                  EFF="$(python tools/select_format.py \
                    --url "$URL" \
                    --trailer "$TID" \
                    $DEFAULT_FLAG \
                    --mode preset_av \
                    --preset-av-profile "${{ inputs.preset_av_profile }}" \
                    --audio-lang "${{ inputs.audio_lang }}" \
                    --sub-lang "${{ inputs.sub_lang }}" \
                  | tail -n 1 | tr -d '\r\n')"
                else
                  EFF="$(python tools/select_format.py \
                    --url "$URL" \
                    --trailer "$TID" \
                    $DEFAULT_FLAG \
                    --mode preset_video \
                    --preset-video-profile "${{ inputs.preset_video_profile }}" \
                    --audio-quality "${{ inputs.audio_quality }}" \
                    --audio-lang "${{ inputs.audio_lang }}" \
                    --sub-lang "${{ inputs.sub_lang }}" \
                  | tail -n 1 | tr -d '\r\n')"
                fi
                RC=$?
                set -e

                if [[ $RC -ne 0 || -z "$EFF" ]]; then
                  sel_failed+=("$TID")
                  echo "::warning::Selector failed for $TID (skipping)."
                  continue
                fi

                echo "$TID $EFF" >> "$PLAN_FILE"
              done

              if [[ ! -s "$PLAN_FILE" ]]; then
                echo "::error::All trailers failed during selection (no plan entries)."
                exit 1
              fi

              echo "::notice::Computed plan (trailer -> format):"
              cat "$PLAN_FILE"

              if [[ ${#sel_failed[@]} -gt 0 ]]; then
                echo "::warning::Selector failed for trailers: ${sel_failed[*]}"
              fi

            else
              # Single trailer preset selection
              echo "DOWNLOAD_ALL=false" >> "$GITHUB_ENV"

              if [[ "$MODE" == "preset_av" ]]; then
                EFF="$(python tools/select_format.py \
                  --url "$URL" \
                  --trailer "$TRAILER" \
                  $DEFAULT_FLAG \
                  --mode preset_av \
                  --preset-av-profile "${{ inputs.preset_av_profile }}" \
                  --audio-lang "${{ inputs.audio_lang }}" \
                  --sub-lang "${{ inputs.sub_lang }}" \
                | tail -n 1 | tr -d '\r\n')"
              else
                EFF="$(python tools/select_format.py \
                  --url "$URL" \
                  --trailer "$TRAILER" \
                  $DEFAULT_FLAG \
                  --mode preset_video \
                  --preset-video-profile "${{ inputs.preset_video_profile }}" \
                  --audio-quality "${{ inputs.audio_quality }}" \
                  --audio-lang "${{ inputs.audio_lang }}" \
                  --sub-lang "${{ inputs.sub_lang }}" \
                | tail -n 1 | tr -d '\r\n')"
              fi

              if [[ -z "$EFF" ]]; then
                echo "::error::Selector returned empty effective format."
                exit 1
              fi

              echo "EFFECTIVE_FORMAT=$EFF" >> "$GITHUB_ENV"
              echo "::notice::preset mode -> computed format: $EFF"
            fi

          else
            echo "::error::Unknown mode '$MODE'"
            exit 1
          fi

      # -------- Phase 2 only (when DO_DOWNLOAD=true) --------

      - name: Cache FFmpeg (BtbN)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: ~/.local/ffmpeg-btbn
          key: ffmpeg-btbn-master-latest-linux64-gpl-v1

      - name: Install FFmpeg (BtbN Daily Build)
        if: ${{ env.DO_DOWNLOAD == 'true' && steps.cache-ffmpeg.outputs.cache-hit != 'true' }}
        run: |
          mkdir -p ~/.local/ffmpeg-btbn
          wget -O /tmp/ffmpeg.tar.xz https://github.com/BtbN/FFmpeg-Builds/releases/latest/download/ffmpeg-master-latest-linux64-gpl.tar.xz
          tar -xf /tmp/ffmpeg.tar.xz -C ~/.local/ffmpeg-btbn --strip-components=1
          ls -la ~/.local/ffmpeg-btbn/bin || true

      - name: Add FFmpeg to PATH
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          echo "$HOME/.local/ffmpeg-btbn/bin" >> $GITHUB_PATH

      - name: Verify FFmpeg in PATH
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          command -v ffmpeg
          ffmpeg -version | head -n 3
          command -v ffprobe
          ffprobe -version | head -n 3

      - name: Install MP4Box (gpac) [Phase 2 only]
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          sudo apt-get update
          sudo apt-get install -y gpac
          command -v MP4Box
          MP4Box -version || true

      - name: Phase 2 - Download (custom single / preset single / preset all)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        env:
          PYTHONUNBUFFERED: "1"
        run: |
          set -euo pipefail

          URL="${{ inputs.url }}"
          DEFAULT_ONLY="${{ inputs.default_only }}"
          TRAILER="${{ inputs.trailer }}"
          MODE="${{ inputs.mode }}"
          DOWNLOAD_ALL="${{ env.DOWNLOAD_ALL }}"
          PLAN_FILE="${{ env.FORMAT_PLAN_FILE }}"
          EFF="${{ env.EFFECTIVE_FORMAT }}"

          default_args=()
          if [[ "$DEFAULT_ONLY" == "true" ]]; then
            default_args+=(--default)
          fi

          failures=()
          success_count=0

          if [[ "$MODE" == "custom" ]]; then
            # single call (Manzana handles trailer=all itself, may fail if IDs mismatch across trailers)
            echo "Using custom EFFECTIVE_FORMAT=$EFF"
            python manzana.py "${default_args[@]}" --no-prompt --trailer "$TRAILER" -f "$EFF" "$URL"
            success_count=1

          else
            if [[ "$DOWNLOAD_ALL" == "true" ]]; then
              if [[ ! -s "$PLAN_FILE" ]]; then
                echo "::error::Plan file missing or empty: $PLAN_FILE"
                exit 1
              fi

              echo "::notice::Downloading multiple trailers (continue on failures)."

              while read -r tid fmt; do
                if [[ -z "$tid" || -z "$fmt" ]]; then
                  continue
                fi

                echo "::notice::Downloading $tid with format=$fmt"
                set +e
                python manzana.py "${default_args[@]}" --no-prompt --trailer "$tid" -f "$fmt" "$URL"
                rc=$?
                set -e

                if [[ $rc -ne 0 ]]; then
                  failures+=("$tid")
                  echo "::warning::Download failed for $tid (rc=$rc). Continuing..."
                else
                  ((success_count+=1))
                fi
              done < "$PLAN_FILE"

            else
              # preset single trailer
              echo "::notice::Downloading single trailer $TRAILER with format=$EFF"
              python manzana.py "${default_args[@]}" --no-prompt --trailer "$TRAILER" -f "$EFF" "$URL"
              success_count=1
            fi
          fi

          if [[ $success_count -le 0 ]]; then
            echo "::error::All downloads failed (no successful outputs)."
            exit 1
          fi

          if [[ ${#failures[@]} -gt 0 ]]; then
            echo "::warning::Some trailers failed to download: ${failures[*]}"
          fi

      - name: Inspect output media info (ffprobe summary + JSON)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          mkdir -p report
          shopt -s nullglob
          files=(output/*.mp4)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No mp4 found in output/"
            exit 1
          fi

          for f in "${files[@]}"; do
            base="$(basename "$f")"
            echo "=== Inspecting: $base ==="

            echo "--- FORMAT (container) ---"
            ffprobe -hide_banner -v error \
              -show_entries format=filename,format_name,duration,size,bit_rate \
              -of default=nw=1 "$f"

            echo "--- STREAMS (tracks, includes bit_rate when available) ---"
            ffprobe -hide_banner -v error \
              -show_entries stream=index,codec_type,codec_name,profile,bit_rate,width,height,avg_frame_rate,channels,channel_layout,sample_rate:stream_tags=language,title \
              -of default=nw=1 "$f"

            echo "--- JSON (artifact) ---"
            ffprobe -hide_banner -v error \
              -show_format -show_streams \
              -print_format json "$f" > "report/${base}.ffprobe.json"
          done

      - name: Upload inspection report as artifact (manzana-report)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: manzana-report
          path: report/
          if-no-files-found: error

      - name: Upload output as artifact (manzana-output)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: manzana-output
          path: output/
          if-no-files-found: error
