name: Manzana Download (Apple TV+ Trailers)

# .github/workflows/manzana-download.yml @ v1.6.4
# Changes vs v1.6.3:
# - When clip fallback is used (COUNT<=1), call:
#     tools/list_clip_urls.py --resolve-titles
#   so Actions logs show human-readable clip names (e.g. 吹替版/字幕版) during:
#     * Phase 1 (optional visibility)
#     * Compute EFFECTIVE_FORMAT / PLAN (main visibility)
# - All other behavior stays the same as v1.6.3:
#     * Phase 1 -F dedup (no duplicated listings)
#     * custom mode supports trailer=all expansion (trailers or clip fallback)
#     * preset modes support clip fallback when API list is incomplete
#     * continue-on-failure semantics for downloads (warn summary, all-fail -> exit 1)

on:
  workflow_dispatch:
    inputs:
      url:
        description: "Apple TV URL (movie/show page)"
        required: true
        type: string

      trailer:
        description: 'Trailer selector: use t0, t1, t2... (e.g. "t0") or "all". In preset modes, "all" will apply presets to each trailer (or clip fallback when API list is incomplete). In custom mode, "all" will loop items with the same format.'
        required: false
        default: "t0"
        type: string

      default_only:
        description: "Use --default (only default trailer metadata). If enabled, the page usually has a single default video (trailer=all behaves like t0)."
        required: false
        default: false
        type: boolean

      mode:
        description: "Selection mode: preset menus (recommended) OR custom format string."
        required: true
        type: choice
        default: preset_av
        options:
          - preset_av
          - preset_video
          - custom

      preset_av_profile:
        description: "Preset A/V profile (ONLY used when mode=preset_av)."
        required: true
        type: choice
        default: 1080_SDR_AAC
        options:
          - 1080_SDR_AAC
          - 4K_DOVI_ATMOS
          - 4K_HDR_DD51

      preset_video_profile:
        description: "Preset video profile (ONLY used when mode=preset_video)."
        required: true
        type: choice
        default: 1080_SDR
        options:
          - 1080_SDR
          - 4K_DOVI
          - 4K_HDR

      audio_quality:
        description: "Audio quality (ONLY used when mode=preset_video). Fallback: if Atmos/DD5.1 not available -> AAC. Use 'none' for a true video-only output."
        required: true
        type: choice
        default: AAC
        options:
          - none
          - AAC
          - Atmos
          - DD5.1

      audio_lang:
        description: 'Audio language (preset modes only). "original" = original-content track. If selected language not available -> fallback to best original AAC.'
        required: true
        type: choice
        default: original
        options:
          - original
          - en
          - cmn-Hans
          - cmn-Hant
          - ja
          - ko
          - fr-FR
          - fr-CA
          - de
          - es-ES
          - es-419
          - it
          - pt-BR
          - ru

      sub_lang:
        description: 'Subtitle language (preset modes only). Default "none". If subtitles missing or language not found -> no subtitles (no error).'
        required: true
        type: choice
        default: none
        options:
          - none
          - en
          - cmn-Hans
          - cmn-Hant
          - ja
          - ko
          - fr-FR
          - fr-CA
          - de
          - es-ES
          - es-419
          - it
          - pt-BR
          - ru

      format:
        description: 'CUSTOM mode only. Leave EMPTY on first run to ONLY LIST formats (Phase 1) and upload formats.txt (NO DOWNLOAD). Then rerun and set format. Must include EXACTLY ONE vN.'
        required: false
        default: ""
        type: string

jobs:
  download:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Validate inputs (fail fast)
        run: |
          set -euo pipefail

          MODE="${{ inputs.mode }}"
          TRAILER="${{ inputs.trailer }}"
          FORMAT_IN="${{ inputs.format }}"

          if [[ -z "$TRAILER" ]]; then
            echo "::error::Input 'trailer' is empty. Use t0, t1, t2... or all."
            exit 1
          fi

          if [[ "$TRAILER" =~ ^(all|a|t[0-9]+)$ ]]; then
            echo "OK: trailer=$TRAILER"
          else
            echo "::error::Invalid trailer input: '$TRAILER'"
            echo "Expected: t0, t1, t2... (t + digits) OR 'all' (or 'a')."
            exit 1
          fi

          if [[ "$MODE" == "custom" ]]; then
            if [[ -z "$FORMAT_IN" ]]; then
              echo "OK: mode=custom and format is EMPTY -> list only, no download."
            else
              F="$FORMAT_IN"
              if [[ ${#F} -ge 2 ]]; then
                if [[ ( "${F:0:1}" == "\"" && "${F: -1}" == "\"" ) || ( "${F:0:1}" == "'" && "${F: -1}" == "'" ) ]]; then
                  F="${F:1:-1}"
                fi
              fi

              if [[ "$F" =~ [[:space:]] ]]; then
                echo "::error::Invalid custom format: contains whitespace. Use '+' between ids, e.g. v6+a0+s4"
                exit 1
              fi

              IFS='+' read -ra PARTS <<< "$F"
              vcount=0
              for p in "${PARTS[@]}"; do
                if [[ -z "$p" ]]; then
                  echo "::error::Invalid custom format: empty token (check for '++')."
                  exit 1
                fi
                if [[ "$p" =~ ^[vV][0-9]+$ ]]; then
                  ((vcount+=1))
                elif [[ "$p" =~ ^[aA][0-9]+$ ]]; then
                  true
                elif [[ "$p" =~ ^[sS][0-9]+$ ]]; then
                  true
                else
                  echo "::error::Invalid token '$p' in custom format."
                  exit 1
                fi
              done

              if [[ "$vcount" -ne 1 ]]; then
                echo "::error::Invalid custom format: must include EXACTLY ONE video id (vN)."
                exit 1
              fi
            fi
          else
            if [[ -n "$FORMAT_IN" ]]; then
              echo "::warning::mode=$MODE: input 'format' will be ignored (preset mode uses selector)."
            fi
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Phase 1 - List formats (-F) and save to formats.txt (dedup, all modes)
        run: |
          set -euo pipefail

          URL="${{ inputs.url }}"
          TRAILER="${{ inputs.trailer }}"
          DEFAULT_ONLY="${{ inputs.default_only }}"

          : > formats.txt

          DEFAULT_FLAG=""
          if [[ "$DEFAULT_ONLY" == "true" ]]; then
            DEFAULT_FLAG="--default-only"
          fi

          if [[ "$DEFAULT_ONLY" == "true" ]]; then
            echo "========== DEFAULT (single) ==========" | tee -a formats.txt
            python manzana.py --default --no-prompt --trailer "$TRAILER" -F "$URL" | tee -a formats.txt
            exit 0
          fi

          if ! [[ "$TRAILER" =~ ^(all|a)$ ]]; then
            echo "========== TRAILER $TRAILER ==========" | tee -a formats.txt
            python manzana.py --no-prompt --trailer "$TRAILER" -F "$URL" | tee -a formats.txt
            exit 0
          fi

          COUNT="$(python tools/list_trailers.py --url "$URL" $DEFAULT_FLAG | tail -n 1 | tr -d '\r\n')"
          if ! [[ "$COUNT" =~ ^[0-9]+$ ]]; then
            echo "::warning::Unable to parse trailer count for Phase 1; falling back to listing t0 only."
            echo "========== TRAILER t0 (fallback) ==========" | tee -a formats.txt
            python manzana.py --no-prompt --trailer t0 -F "$URL" | tee -a formats.txt
            exit 0
          fi

          if [[ "$COUNT" -gt 1 ]]; then
            echo "========== ALL TRAILERS (t0..t$((COUNT-1))) ==========" | tee -a formats.txt
            for ((i=0;i<COUNT;i++)); do
              echo "" | tee -a formats.txt
              echo "========== TRAILER t${i} ==========" | tee -a formats.txt
              python manzana.py --no-prompt --trailer "t${i}" -F "$URL" | tee -a formats.txt
            done
            exit 0
          fi

          echo "========== ALL (clip fallback) ==========" | tee -a formats.txt

          # v1.6.4: --resolve-titles (stderr only) so Actions logs show clip names
          mapfile -t CLIPS_RAW < <(python tools/list_clip_urls.py --url "$URL" $DEFAULT_FLAG --resolve-titles)

          if [[ ${#CLIPS_RAW[@]} -le 0 ]]; then
            echo "::warning::Clip fallback found 0 clip URLs. Listing trailer t0 as last resort." | tee -a formats.txt
            echo "========== TRAILER t0 (fallback) ==========" | tee -a formats.txt
            python manzana.py --no-prompt --trailer t0 -F "$URL" | tee -a formats.txt
            exit 0
          fi

          declare -A seen=()
          CLIPS=()
          for c in "${CLIPS_RAW[@]}"; do
            c="$(printf "%s" "$c" | tr -d '\r\n')"
            if [[ -z "$c" ]]; then
              continue
            fi
            if [[ -n "${seen[$c]+x}" ]]; then
              continue
            fi
            seen["$c"]=1
            CLIPS+=("$c")
          done

          echo "::notice::Phase 1 will list formats for ${#CLIPS[@]} clip(s) (no duplicates)." | tee -a formats.txt

          for clip_url in "${CLIPS[@]}"; do
            echo "" | tee -a formats.txt
            echo "========== CLIP: $clip_url ==========" | tee -a formats.txt
            python manzana.py --no-prompt --trailer t0 -F "$clip_url" | tee -a formats.txt
          done

      - name: Upload formats as artifact (manzana-formats)
        uses: actions/upload-artifact@v4
        with:
          name: manzana-formats
          path: formats.txt
          if-no-files-found: error

      - name: Compute EFFECTIVE_FORMAT / PLAN (preset/custom)
        run: |
          set -euo pipefail

          MODE="${{ inputs.mode }}"
          URL="${{ inputs.url }}"
          TRAILER="${{ inputs.trailer }}"
          DEFAULT_ONLY="${{ inputs.default_only }}"

          DEFAULT_FLAG=""
          if [[ "$DEFAULT_ONLY" == "true" ]]; then
            DEFAULT_FLAG="--default-only"
          fi

          PLAN_FILE="$RUNNER_TEMP/manzana_plan.txt"
          : > "$PLAN_FILE"
          echo "FORMAT_PLAN_FILE=$PLAN_FILE" >> "$GITHUB_ENV"

          if [[ "$MODE" == "custom" ]]; then
            F="${{ inputs.format }}"
            if [[ ${#F} -ge 2 ]]; then
              if [[ ( "${F:0:1}" == "\"" && "${F: -1}" == "\"" ) || ( "${F:0:1}" == "'" && "${F: -1}" == "'" ) ]]; then
                F="${F:1:-1}"
              fi
            fi
            F="$(printf "%s" "$F" | tr -d '\r\n')"

            if [[ -z "$F" ]]; then
              echo "EFFECTIVE_FORMAT=" >> "$GITHUB_ENV"
              echo "DO_DOWNLOAD=false" >> "$GITHUB_ENV"
              echo "DOWNLOAD_ALL=false" >> "$GITHUB_ENV"
              echo "PLAN_KIND=single" >> "$GITHUB_ENV"
              echo "mode=custom: format empty -> list only, no download."
              exit 0
            fi

            echo "DO_DOWNLOAD=true" >> "$GITHUB_ENV"

            if [[ "$TRAILER" =~ ^(all|a)$ ]]; then
              COUNT="$(python tools/list_trailers.py --url "$URL" $DEFAULT_FLAG | tail -n 1 | tr -d '\r\n')"
              if ! [[ "$COUNT" =~ ^[0-9]+$ ]]; then
                echo "::error::Unable to parse trailer count: '$COUNT'"
                exit 1
              fi

              if [[ "$COUNT" -gt 1 ]]; then
                echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
                echo "PLAN_KIND=trailers" >> "$GITHUB_ENV"
                echo "::notice::custom mode + trailer=all -> API trailers count=$COUNT (t0..t$((COUNT-1))). Using the SAME format for each."

                for ((i=0;i<COUNT;i++)); do
                  echo "t${i} $F" >> "$PLAN_FILE"
                done

                echo "::notice::Computed plan (trailer -> format):"
                cat "$PLAN_FILE"
                exit 0
              fi

              echo "::notice::custom mode + trailer=all -> API count=$COUNT (<=1). Falling back to clip URLs from HTML..."
              echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
              echo "PLAN_KIND=clips" >> "$GITHUB_ENV"

              # v1.6.4: --resolve-titles prints names to stderr for better logs
              mapfile -t CLIPS < <(python tools/list_clip_urls.py --url "$URL" $DEFAULT_FLAG --resolve-titles)
              if [[ ${#CLIPS[@]} -le 0 ]]; then
                echo "::error::Clip fallback found 0 clip URLs. Unable to continue."
                exit 1
              fi

              for clip_url in "${CLIPS[@]}"; do
                clip_url="$(printf "%s" "$clip_url" | tr -d '\r\n')"
                if [[ -z "$clip_url" ]]; then
                  continue
                fi
                echo "$clip_url $F" >> "$PLAN_FILE"
              done

              echo "::notice::Computed plan (clip_url -> format):"
              cat "$PLAN_FILE"
              exit 0
            fi

            echo "EFFECTIVE_FORMAT=$F" >> "$GITHUB_ENV"
            echo "DOWNLOAD_ALL=false" >> "$GITHUB_ENV"
            echo "PLAN_KIND=single" >> "$GITHUB_ENV"
            echo "mode=custom: will download with format: $F"
            exit 0

          elif [[ "$MODE" == "preset_av" || "$MODE" == "preset_video" ]]; then
            echo "DO_DOWNLOAD=true" >> "$GITHUB_ENV"

            if [[ "$TRAILER" =~ ^(all|a)$ ]]; then
              COUNT="$(python tools/list_trailers.py --url "$URL" $DEFAULT_FLAG | tail -n 1 | tr -d '\r\n')"
              if ! [[ "$COUNT" =~ ^[0-9]+$ ]]; then
                echo "::error::Unable to parse trailer count: '$COUNT'"
                exit 1
              fi

              if [[ "$COUNT" -gt 1 ]]; then
                echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
                echo "PLAN_KIND=trailers" >> "$GITHUB_ENV"
                echo "::notice::preset mode + trailer=all -> API trailers count=$COUNT (t0..t$((COUNT-1)))."

                sel_failed=()

                for ((i=0;i<COUNT;i++)); do
                  TID="t${i}"
                  set +e
                  if [[ "$MODE" == "preset_av" ]]; then
                    EFF="$(python tools/select_format.py \
                      --url "$URL" \
                      --trailer "$TID" \
                      $DEFAULT_FLAG \
                      --mode preset_av \
                      --preset-av-profile "${{ inputs.preset_av_profile }}" \
                      --audio-lang "${{ inputs.audio_lang }}" \
                      --sub-lang "${{ inputs.sub_lang }}" \
                    | tail -n 1 | tr -d '\r\n')"
                  else
                    EFF="$(python tools/select_format.py \
                      --url "$URL" \
                      --trailer "$TID" \
                      $DEFAULT_FLAG \
                      --mode preset_video \
                      --preset-video-profile "${{ inputs.preset_video_profile }}" \
                      --audio-quality "${{ inputs.audio_quality }}" \
                      --audio-lang "${{ inputs.audio_lang }}" \
                      --sub-lang "${{ inputs.sub_lang }}" \
                    | tail -n 1 | tr -d '\r\n')"
                  fi
                  RC=$?
                  set -e

                  if [[ $RC -ne 0 || -z "$EFF" ]]; then
                    sel_failed+=("$TID")
                    echo "::warning::Selector failed for $TID (skipping)."
                    continue
                  fi

                  echo "$TID $EFF" >> "$PLAN_FILE"
                done

                if [[ ! -s "$PLAN_FILE" ]]; then
                  echo "::error::All trailers failed during selection (no plan entries)."
                  exit 1
                fi

                echo "::notice::Computed plan (trailer -> format):"
                cat "$PLAN_FILE"
                if [[ ${#sel_failed[@]} -gt 0 ]]; then
                  echo "::warning::Selector failed for trailers: ${sel_failed[*]}"
                fi

              else
                echo "::notice::API trailer count=$COUNT (<=1). Falling back to clip URLs from HTML..."
                echo "DOWNLOAD_ALL=true" >> "$GITHUB_ENV"
                echo "PLAN_KIND=clips" >> "$GITHUB_ENV"

                # v1.6.4: --resolve-titles prints names to stderr for better logs
                mapfile -t CLIPS < <(python tools/list_clip_urls.py --url "$URL" $DEFAULT_FLAG --resolve-titles)

                if [[ ${#CLIPS[@]} -le 0 ]]; then
                  echo "::error::Clip fallback found 0 clip URLs. Unable to continue."
                  exit 1
                fi

                echo "::notice::Clip fallback: found ${#CLIPS[@]} clip URLs."
                sel_failed=()

                for clip_url in "${CLIPS[@]}"; do
                  clip_url="$(printf "%s" "$clip_url" | tr -d '\r\n')"
                  if [[ -z "$clip_url" ]]; then
                    continue
                  fi

                  set +e
                  if [[ "$MODE" == "preset_av" ]]; then
                    EFF="$(python tools/select_format.py \
                      --url "$clip_url" \
                      --trailer t0 \
                      $DEFAULT_FLAG \
                      --mode preset_av \
                      --preset-av-profile "${{ inputs.preset_av_profile }}" \
                      --audio-lang "${{ inputs.audio_lang }}" \
                      --sub-lang "${{ inputs.sub_lang }}" \
                    | tail -n 1 | tr -d '\r\n')"
                  else
                    EFF="$(python tools/select_format.py \
                      --url "$clip_url" \
                      --trailer t0 \
                      $DEFAULT_FLAG \
                      --mode preset_video \
                      --preset-video-profile "${{ inputs.preset_video_profile }}" \
                      --audio-quality "${{ inputs.audio_quality }}" \
                      --audio-lang "${{ inputs.audio_lang }}" \
                      --sub-lang "${{ inputs.sub_lang }}" \
                    | tail -n 1 | tr -d '\r\n')"
                  fi
                  RC=$?
                  set -e

                  if [[ $RC -ne 0 || -z "$EFF" ]]; then
                    sel_failed+=("$clip_url")
                    echo "::warning::Selector failed for clip URL (skipping): $clip_url"
                    continue
                  fi

                  echo "$clip_url $EFF" >> "$PLAN_FILE"
                done

                if [[ ! -s "$PLAN_FILE" ]]; then
                  echo "::error::All clip URLs failed during selection (no plan entries)."
                  exit 1
                fi

                echo "::notice::Computed plan (clip_url -> format):"
                cat "$PLAN_FILE"
                if [[ ${#sel_failed[@]} -gt 0 ]]; then
                  echo "::warning::Selector failed for some clip URLs (${#sel_failed[@]})."
                fi
              fi

            else
              echo "DOWNLOAD_ALL=false" >> "$GITHUB_ENV"
              echo "PLAN_KIND=single" >> "$GITHUB_ENV"

              if [[ "$MODE" == "preset_av" ]]; then
                EFF="$(python tools/select_format.py \
                  --url "$URL" \
                  --trailer "$TRAILER" \
                  $DEFAULT_FLAG \
                  --mode preset_av \
                  --preset-av-profile "${{ inputs.preset_av_profile }}" \
                  --audio-lang "${{ inputs.audio_lang }}" \
                  --sub-lang "${{ inputs.sub_lang }}" \
                | tail -n 1 | tr -d '\r\n')"
              else
                EFF="$(python tools/select_format.py \
                  --url "$URL" \
                  --trailer "$TRAILER" \
                  $DEFAULT_FLAG \
                  --mode preset_video \
                  --preset-video-profile "${{ inputs.preset_video_profile }}" \
                  --audio-quality "${{ inputs.audio_quality }}" \
                  --audio-lang "${{ inputs.audio_lang }}" \
                  --sub-lang "${{ inputs.sub_lang }}" \
                | tail -n 1 | tr -d '\r\n')"
              fi

              if [[ -z "$EFF" ]]; then
                echo "::error::Selector returned empty effective format."
                exit 1
              fi

              echo "EFFECTIVE_FORMAT=$EFF" >> "$GITHUB_ENV"
              echo "::notice::preset mode -> computed format: $EFF"
            fi

          else
            echo "::error::Unknown mode '$MODE'"
            exit 1
          fi

      - name: Cache FFmpeg (BtbN)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: ~/.local/ffmpeg-btbn
          key: ffmpeg-btbn-master-latest-linux64-gpl-v1

      - name: Install FFmpeg (BtbN Daily Build)
        if: ${{ env.DO_DOWNLOAD == 'true' && steps.cache-ffmpeg.outputs.cache-hit != 'true' }}
        run: |
          mkdir -p ~/.local/ffmpeg-btbn
          wget -O /tmp/ffmpeg.tar.xz https://github.com/BtbN/FFmpeg-Builds/releases/latest/download/ffmpeg-master-latest-linux64-gpl.tar.xz
          tar -xf /tmp/ffmpeg.tar.xz -C ~/.local/ffmpeg-btbn --strip-components=1
          ls -la ~/.local/ffmpeg-btbn/bin || true

      - name: Add FFmpeg to PATH
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          echo "$HOME/.local/ffmpeg-btbn/bin" >> $GITHUB_PATH

      - name: Verify FFmpeg in PATH
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          command -v ffmpeg
          ffmpeg -version | head -n 3
          command -v ffprobe
          ffprobe -version | head -n 3

      - name: Install MP4Box (gpac) [Phase 2 only]
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          sudo apt-get update
          sudo apt-get install -y gpac
          command -v MP4Box
          MP4Box -version || true

      - name: Phase 2 - Download (custom single / custom all / preset single / preset all + clip fallback)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        env:
          PYTHONUNBUFFERED: "1"
        run: |
          set -euo pipefail

          URL="${{ inputs.url }}"
          DEFAULT_ONLY="${{ inputs.default_only }}"
          TRAILER="${{ inputs.trailer }}"
          MODE="${{ inputs.mode }}"
          DOWNLOAD_ALL="${{ env.DOWNLOAD_ALL }}"
          PLAN_KIND="${{ env.PLAN_KIND }}"
          PLAN_FILE="${{ env.FORMAT_PLAN_FILE }}"
          EFF="${{ env.EFFECTIVE_FORMAT }}"

          default_args=()
          if [[ "$DEFAULT_ONLY" == "true" ]]; then
            default_args+=(--default)
          fi

          failures=()
          success_count=0

          if [[ "$DOWNLOAD_ALL" == "true" ]]; then
            if [[ ! -s "$PLAN_FILE" ]]; then
              echo "::error::Plan file missing or empty: $PLAN_FILE"
              exit 1
            fi

            echo "::notice::Downloading multiple items (continue on failures). PLAN_KIND=$PLAN_KIND MODE=$MODE"

            while read -r target fmt; do
              if [[ -z "$target" || -z "$fmt" ]]; then
                continue
              fi

              if [[ "$PLAN_KIND" == "clips" ]]; then
                clip_url="$target"
                echo "::notice::Downloading clip URL with format=$fmt"
                set +e
                python manzana.py "${default_args[@]}" --no-prompt --trailer t0 -f "$fmt" "$clip_url"
                rc=$?
                set -e
                if [[ $rc -ne 0 ]]; then
                  failures+=("$clip_url")
                  echo "::warning::Download failed for clip (rc=$rc). Continuing..."
                else
                  ((success_count+=1))
                fi
              else
                tid="$target"
                echo "::notice::Downloading $tid with format=$fmt"
                set +e
                python manzana.py "${default_args[@]}" --no-prompt --trailer "$tid" -f "$fmt" "$URL"
                rc=$?
                set -e
                if [[ $rc -ne 0 ]]; then
                  failures+=("$tid")
                  echo "::warning::Download failed for $tid (rc=$rc). Continuing..."
                else
                  ((success_count+=1))
                fi
              fi
            done < "$PLAN_FILE"

          else
            echo "::notice::Downloading single trailer $TRAILER with format=$EFF"
            python manzana.py "${default_args[@]}" --no-prompt --trailer "$TRAILER" -f "$EFF" "$URL"
            success_count=1
          fi

          if [[ $success_count -le 0 ]]; then
            echo "::error::All downloads failed (no successful outputs)."
            exit 1
          fi

          if [[ ${#failures[@]} -gt 0 ]]; then
            echo "::warning::Some items failed to download:"
            for f in "${failures[@]}"; do
              echo "::warning:: - $f"
            done
          fi

      - name: Inspect output media info (ffprobe summary + JSON)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        run: |
          mkdir -p report
          shopt -s nullglob
          files=(output/*.mp4)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No mp4 found in output/"
            exit 1
          fi

          for f in "${files[@]}"; do
            base="$(basename "$f")"
            echo "=== Inspecting: $base ==="

            echo "--- FORMAT (container) ---"
            ffprobe -hide_banner -v error \
              -show_entries format=filename,format_name,duration,size,bit_rate \
              -of default=nw=1 "$f"

            echo "--- STREAMS (tracks, includes bit_rate when available) ---"
            ffprobe -hide_banner -v error \
              -show_entries stream=index,codec_type,codec_name,profile,bit_rate,width,height,avg_frame_rate,channels,channel_layout,sample_rate:stream_tags=language,title \
              -of default=nw=1 "$f"

            echo "--- JSON (artifact) ---"
            ffprobe -hide_banner -v error \
              -show_format -show_streams \
              -print_format json "$f" > "report/${base}.ffprobe.json"
          done

      - name: Upload inspection report as artifact (manzana-report)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: manzana-report
          path: report/
          if-no-files-found: error

      - name: Upload output as artifact (manzana-output)
        if: ${{ env.DO_DOWNLOAD == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: manzana-output
          path: output/
          if-no-files-found: error
